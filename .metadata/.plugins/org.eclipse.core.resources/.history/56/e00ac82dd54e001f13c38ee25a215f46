/*
 * velocity.c
 *
 *  Created on: Jul 23, 2024
 *      Author: RND_220516
 */

// includes
#include "velocity.h"
#include "main.h"
#include "config.h"
#include "math.h"

// variable
uint8_t is_left_not_ready, is_right_not_ready;
uint32_t last_time, target_ARR;
float target_motor_RPM;
float current_motor_RPM;
float current_velocity;	// m/s
float motor_RPM_change;

// function prototypes
float Cal_motor_RPM(float velocity);
uint32_t Cal_ARR(TIM_HandleTypeDef *htim, float motor_rpm);

void Velocity(float *target_velocity)
{
	// update target velocity
	if (current_velocity != *target_velocity)
	{
		current_velocity = *target_velocity;	// update current velocity

		target_motor_RPM = Cal_motor_RPM(*target_velocity);	// calculate target motor RPM

		motor_RPM_change = (target_motor_RPM - current_motor_RPM) / CHANGE_SEGMENTS;	// calculate motor RPM per change segments
	}

	if (timer_counter % 10 == 0)
	{
		// sync timing
		if (upbit_flag)
		{
			upbit_flag = 0;

			// handling out-of-range values
			if (motor_RPM_change > 0)
			{
				if ((current_motor_RPM += motor_RPM_change) >= target_motor_RPM)
				{
					current_motor_RPM = target_motor_RPM;
				}
			}
			else if (motor_RPM_change < 0)
			{
				if ((current_motor_RPM += motor_RPM_change) <= target_motor_RPM)
				{
					current_motor_RPM = target_motor_RPM;
				}
			}
			else {
				current_motor_RPM = target_motor_RPM;
			}

			// check motor RPM limit
			if (current_motor_RPM > MOTOR_RPM_LIMIT)
			{
				current_motor_RPM = MOTOR_RPM_LIMIT;
			}
			else if (current_motor_RPM)
			{
				target_ARR = Cal_ARR(&htim5, current_motor_RPM);
			}
			else
			{
				target_ARR = 0;
			}

	  	// update AMP state
//  	  	is_left_not_ready 	= HAL_GPIO_ReadPin(GPIOG, SDI0_Pin);
//  	  	is_right_not_ready 	= HAL_GPIO_ReadPin(GPIOG, SDI4_Pin);

			// is AMP ready
			if(!is_left_not_ready && !is_right_not_ready)
			{
				// stop PWM
				if (target_ARR == 0)
				{
					target_ARR = 0;
//					if (HAL_TIM_PWM_Stop(&htim5, TIM_CHANNEL_1) != HAL_OK)
//					{
//						Error_Handler();
//					}
				}
				// start PWM
				else
				{
					// check timer channel is ready
					if (htim5.ChannelState[0] == HAL_TIM_CHANNEL_STATE_READY)
					{
						if (HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_1) != HAL_OK)
						{
							Error_Handler();
						}
					}
					// set PWM instance
				}
				TIM5->ARR = target_ARR;
				TIM5->CCR1 = target_ARR * 0.5;
			}
		}
	}
}

// define functions
float Cal_motor_RPM(float velocity)
{
	return (velocity * MIN_TO_SEC * GEAR_RATIO) / (WHEEL_DIAMETER * M_PI);
}

uint32_t Cal_ARR(TIM_HandleTypeDef *htim, float motor_rpm)
{
	// waring the variable max value
	// if calculate MCU_CLOCK * MIN_TO_SEC first then value = 5,040,000,000(X) -> 4,294,967,296 (O)
	return MCU_CLOCK / ((htim->Instance->PSC + 1) * AMP_PPR * motor_rpm) * MIN_TO_SEC;
}
